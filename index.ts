declare global {
  interface SymbolConstructor {
    _hapticaPrivate: Symbol;
  }
}

Symbol._hapticaPrivate = Symbol("_hapticaPrivate");

const _hapticaInternalConstructorCheck = (key: Symbol) => {
  if (key !== Symbol._hapticaPrivate) {
    throw new TypeError("Illegal constructor");
  }
};

interface HapticaConstructor {
  new (key: Symbol, ...args: any): any;
}

const _hapticaConstructPrivate = <V>(constructor: any, ...args: any): V => {
  return new (constructor as HapticaConstructor)(
    Symbol._hapticaPrivate,
    ...args,
  );
};

// const _hapticaConstructPrivate = <T extends Class>()

export type HapticaUnsubscribe = () => void;

/**
 * A data type describing a version of the app.
 *
 * You can get the current app version using the {@link HAPTICA_APP_VERSION} constant.
 */
export type HapticaSemanticVersion = {
  majorVersion: number;
  minorVersion: number;
  patchVersion: number;
};

export type HapticaExtensionErrorCode =
  | "ExtensionManifestNotRegistered"
  | "SettingNameNotFound"
  | "InvalidSettingValue"
  | "PatternWithIdNotFound"
  | "AccessForbidden";

/**
 * An owner of a resource managed by the app.
 */
export type HapticaResourceOwner =
  | {
      /**
       * The resource is owned by the main application.
       */
      type: "main-application";
    }
  | {
      /**
       * The resource is owned by an extension.
       */
      type: "extension";

      /**
       * The id of the extension that owns the resource.
       */
      id: HapticaExtensionID;
    };

/**
 * The creator of a resource in the app..
 *
 * `"user"` - The resource was created directly by the user.
 *
 * `"extension"` - The resouce was created by an extension.
 *
 * `"main-application"` - The resource was auto-generated by the main application.
 */
export type HapticaResourceCreator = HapticaResourceOwner | { type: "user" };

/**
 * A union of permission types for a haptica-owned resource.
 */
export type HapticaResourcePermissions = "read" | "write" | "delete";

export type HapticaAudioFileID = string;

/**
 * A union of access permission identifiers for your extension.
 *
 * `"read-global"` = Your extension has read-only access to all patterns stored in the app.
 *
 * `"read-write-local"` = Your extension has read-write access to a list of patterns that it privately owns.
 */
export type HapticaAudioDirectoryAccessPermission =
  | "read-global"
  | "read-write-local";

/**
 * The label of an {@link HapticaAudioFile}.
 */
export type HapticaAudioFileLabel = {
  /**
   * The raw filename of the file.
   */
  filename: string;

  /**
   * The {@link HapticaResourceOwner} of the file.
   */
  owner: HapticaResourceOwner;
};

/**
 * The result of attempting to rename an {@link HapticaAudioFile}.
 */
export type HapticaAudioFileRenameResult =
  | { status: "success"; newLabel: HapticaAudioFileLabel }
  | { status: "file-already-exists" | "file-not-found" };

/**
 * Required fields to rename an {@link HapticaAudioFile}.
 */
export type HapticaAudioFileRename = {
  /**
   * The id of the file to rename.
   */
  id: HapticaAudioFileID;

  /**
   * The new name of the file **WITHOUT** the file extension applied.
   */
  nameWithoutExtension: string;
};

/**
 * Required fields to create a new {@link HapticaAudioFile}.
 */
export type HapticaAudioFileCreate = {
  /**
   * The {@link HapticaAudioFileLabel} of the file to create.
   */
  label: HapticaAudioFileLabel;

  /**
   * The initial data of the file to create.
   */
  initialData: Blob;
};

/**
 * An emitted event when listening for changes on a {@link HapticaAudioFile}.
 */
export type HapticaAudioFileChangeEvent = { type: "rename" | "delete" };

/**
 * An audio file owned by the app.
 */
export interface HapticaAudioFile {
  /**
   * The id of this file.
   */
  id: HapticaAudioFileID;

  /**
   * The label of this file.
   */
  label: HapticaAudioFileLabel;

  /**
   * The set of available permissions that your extension has with this file.
   */
  permissions: Set<HapticaResourcePermissions>;

  /**
   * The creation date of this file.
   */
  createdAt: Date;

  /**
   * The date this file was last modified.
   */
  lastModifiedAt: Date;

  /**
   * Subscribes to changes in this file.
   *
   * @param callback A callback function to handle changes.
   * @returns A function to unsubscribe from changes.
   */
  subscribeToChanges(
    callback: (event: HapticaAudioFileChangeEvent) => void,
  ): HapticaUnsubscribe;

  /**
   * This file as a blob.
   */
  blob(): Blob;

  /**
   * Saves the bytes in the specified `blob` to this file.
   */
  saveBytes(blob: Blob): Promise<void>;
}

/**
 * Access to the audio directory for your extension/
 */
export class HapticaAudioDirectory {
  private constructor(key: Symbol) {
    _hapticaInternalConstructorCheck(key);
  }

  /**
   * Creates a new file in this directory.
   *
   * @param create {@link HapticaAudioFileCreate}
   * @returns The created file.
   */
  async createNewFile(create: HapticaAudioFileCreate) {
    return (await this.createNewFiles([create]))[0];
  }

  /**
   * Creates new files in this directory.
   *
   * @param creates {@link HapticaAudioFileCreate}
   * @returns The created files.
   */
  async createNewFiles(creates: HapticaAudioFileCreate[]) {
    return await _hapticaPrimitives.audioDirectoryCreateNewFiles(creates);
  }

  /**
   * Lists all files in this directory.
   *
   * @returns The files.
   */
  async files() {
    return await _hapticaPrimitives.audioDirectoryFiles();
  }

  /**
   * Gets a file by its ID.
   *
   * @param id The ID of the file.
   * @returns The file.
   */
  async fileById(id: HapticaAudioFileID) {
    return (await this.filesByIds([id]))[0];
  }

  /**
   * Gets files by their IDs.
   *
   * @param ids The IDs of the files.
   * @returns The files.
   */
  async filesByIds(ids: HapticaAudioFileID[]) {
    return _hapticaPrimitives.audioDirectoryFilesForIds(ids);
  }

  /**
   * Gets a file by its label.
   *
   * @param label The label of the file.
   * @returns The file.
   */
  async fileByLabel(label: HapticaAudioFileLabel) {
    return (await this.filesByLabels([label]))[0];
  }

  /**
   * Gets files by their labels.
   *
   * @param labels The labels of the files.
   * @returns The files.
   */
  async filesByLabels(labels: HapticaAudioFileLabel[]) {
    return _hapticaPrimitives.audioDirectoryFilesForLabels(labels);
  }

  /**
   * Renames a file.
   *
   * @param rename The rename operation.
   * @returns The renamed file.
   */
  async renameFile(rename: HapticaAudioFileRename) {
    return (await this.renameFiles([rename]))[0];
  }

  /**
   * Renames files.
   *
   * @param renames The rename operations.
   * @returns The renamed files.
   */
  async renameFiles(renames: HapticaAudioFileRename[]) {
    return _hapticaPrimitives.audioDirectoryRenameFiles(renames);
  }

  /**
   * Deletes a file.
   *
   * @param id The id of the file.
   */
  async deleteFileById(id: HapticaAudioFileID) {
    await this.deleteFilesByIds([id]);
  }

  /**
   * Deletes files.
   *
   * @param ids The ids of the files.
   */
  async deleteFilesByIds(ids: HapticaAudioFileID[]) {
    await _hapticaPrimitives.audioDirectoryDeleteFilesByIds(ids);
  }
}

/**
 * Parameter ids that can be used for haptic events.
 */
const HAPTICA_AHAP_HAPTIC_PARAMETER_IDS = [
  "HapticIntensity",
  "HapticSharpness",
  "AttackTime",
  "DecayTime",
  "ReleaseTime",
  "Sustained",
] as const;

/**
 * A parameter id that can be used for haptic events.
 */
export type HapticaAHAPHapticParameterID =
  (typeof HAPTICA_AHAP_HAPTIC_PARAMETER_IDS)[number];

/**
 * Parameter ids that can be used for audio events.
 */
const HAPTICA_AHAP_AUDIO_PARAMETER_IDS = [
  "AudioVolume",
  "AudioPan",
  "AudioPitch",
  "AudioBrightness",
] as const;

/**
 * A parameter id that can be used for audio events.
 */
export type HapticaAHAPAudioParameterID =
  (typeof HAPTICA_AHAP_AUDIO_PARAMETER_IDS)[number];

/**
 * A parameter id for an {@link HapticaAHAPEvent}.
 */
export type HapticaAHAPEventParameterID =
  | HapticaAHAPHapticParameterID
  | HapticaAHAPAudioParameterID;

/**
 * A parameter id with its associated value.
 */
export type HapticaAHAPEventParameter<ID extends HapticaAHAPEventParameterID> =
  {
    ParameterID: ID;
    ParameterValue: number;
  };

type HapticaAHAPBaseEvent<Event> = Event & { Time: number };

/**
 * A haptic transient event from CoreHaptics.
 */
export type HapticaAHAPHapticTransientEvent = HapticaAHAPBaseEvent<{
  EventType: "HapticTransient";
  EventDuration?: number;
  EventParameters: HapticaAHAPEventParameter<HapticaAHAPHapticParameterID>[];
}>;

/**
 * A haptic continuous event from CoreHaptics.
 */
export type HapticaAHAPHapticContinuousEvent = HapticaAHAPBaseEvent<{
  EventType: "HapticContinuous";
  EventParameters: HapticaAHAPEventParameter<HapticaAHAPHapticParameterID>[];
  EventDuration: number;
}>;

/**
 * An audio custom event from CoreHaptics.
 */
export type HapticaAHAPAudioCustomEvent = HapticaAHAPBaseEvent<{
  EventType: "AudioCustom";
  EventWaveformPath: HapticaAudioFileID;
  EventDuration?: number;
  EventWaveformLoopEnabled?: boolean;
  EventWaveformUseVolumeEnvelope?: boolean;
  EventParameters: HapticaAHAPEventParameter<HapticaAHAPAudioParameterID>[];
}>;

/**
 * An audio continuous event from CoreHaptics.
 */
export type HapticaAHAPAudioContinuousEvent = HapticaAHAPBaseEvent<{
  EventType: "AudioContinuous";
  EventDuration: number;
  EventWaveformUseVolumeEnvelope?: boolean;
  EventParameters: HapticaAHAPEventParameter<HapticaAHAPAudioParameterID>[];
}>;

/**
 * A type of haptic event to be played at a specified moment in time.
 */
export type HapticaAHAPEvent =
  | HapticaAHAPHapticTransientEvent
  | HapticaAHAPHapticContinuousEvent
  | HapticaAHAPAudioCustomEvent
  | HapticaAHAPAudioContinuousEvent;

/**
 * All possible paramater ids that can be used with an {@link HapticaAHAPParameterCurve}.
 */
const HAPTICA_AHAP_CURVABLE_PARAMETER_IDS = [
  "HapticIntensityControl",
  "HapticSharpnessControl",
  "AudioVolumeControl",
  "AudioPanControl",
  "AudioPitchControl",
  "AudioBrightnessControl",
] as const;

/**
 * A parameter id for {@link HapticaAHAPParameterCurve}s.
 */
export type AHAPCurvableParameterID =
  (typeof HAPTICA_AHAP_CURVABLE_PARAMETER_IDS)[number];

/**
 * All possible paramater ids that can be used with an {@link HapticaAHAPDynamicParameter}.
 */
const HAPTICA_AHAP_DYNAMIC_PARAMETER_IDS = [
  ...HAPTICA_AHAP_CURVABLE_PARAMETER_IDS,
  "HapticAttackTimeControl",
  "HapticDecayTimeControl",
  "HapticReleaseTimeControl",
  "AudioAttackTimeControl",
  "AudioDecayTimeControl",
  "AudioReleaseTimeControl",
] as const;

/**
 * A parameter id for {@link HapticaAHAPDynamicParameter}s.
 */
export type HapticaAHAPDynamicParameterID =
  (typeof HAPTICA_AHAP_DYNAMIC_PARAMETER_IDS)[number];

/**
 * A value that alters the playback of haptic event parameters at a particular time.
 *
 * For interpolation of parameter values over time, see {@link HapticaAHAPParameterCurve}.
 */
export type HapticaAHAPDynamicParameter = {
  ParameterID: HapticaAHAPDynamicParameterID;
  ParameterValue: number;
  Time: number;
};

/**
 * A type that controls the change in a haptic parameter value using a key-frame system.
 *
 * For altering parameter values at a particular point see {@link HapticaAHAPDynamicParameter}.
 */
export type HapticaAHAPParameterCurve = {
  ParameterID: AHAPCurvableParameterID;
  Time: number;
  ParameterCurveControlPoints: HapticaAHAPParameterCurveControlPoint[];
};

/**
 * A control point for a {@link HapticaAHAPParameterCurve}.
 */
export type HapticaAHAPParameterCurveControlPoint = {
  ParameterValue: number;
  Time: number;
};

/**
 * An element in an {@link HapticaAHAPPattern}.
 */
export type HapticaAHAPPatternElement =
  | { Event: HapticaAHAPEvent }
  | { Parameter: HapticaAHAPDynamicParameter }
  | { ParameterCurve: HapticaAHAPParameterCurve };

/**
 * A type for a haptic pattern.
 *
 * Haptic patterns are composed of events and parameters. See {@link HapticaAHAPEvent},
 * {@link HapticaAHAPDynamicParameter}, and {@link HapticaAHAPParameterCurve} for more.
 */
export type HapticaAHAPPattern = {
  Version: 1;
  Metadata?: Record<string, any>;
  Pattern: HapticaAHAPPatternElement[];
};

/**
 * An ID of an {@link HapticaPattern}.
 *
 * This is typically a v7 UUID.
 */
export type HapticaPatternID = string;

/**
 * A haptic pattern stored by the app.
 */
export type HapticaPattern = {
  /**
   * The ID of the haptic pattern.
   */
  id: HapticaPatternID;

  /**
   * The name of the pattern.
   */
  name: string;

  /**
   * The AHAP data of the pattern.
   */
  ahapPattern: HapticaAHAPPattern;

  /**
   * The {@link HapticaResourceOwner} of the pattern.
   */
  owner: HapticaResourceOwner;

  /**
   * The date the pattern was last edited at.
   */
  lastEditedAt: Date;

  /**
   * The date the pattern was created at.
   */
  createdAt: Date;

  /**
   * The {@link HapticaResourcePermissions} that this extension has to interact with the pattern.
   */
  permissions: Set<HapticaResourcePermissions>;
};

/**
 * A sort descriptor for use in a {@link HapticaPatternsQuery}.
 */
export type HapticaPatternsSortDescriptor = {
  property: "name" | "createdAt" | "lastEditedAt";
  order: "asc" | "desc";
};

/**
 * A type for querying {@link HapticaPattern}s.
 */
export type HapticaPatternsQuery = {
  /**
   * A predicate to filter patterns.
   *
   * @param pattern The pattern to filter.
   * @returns Whether the pattern matches the filter.
   */
  filter?: (pattern: HapticaPattern) => boolean;

  /**
   * An array of sort descriptors.
   */
  sortedBy?: HapticaPatternsSortDescriptor[];
};

/**
 * Required fields for creating a new {@link HapticaPattern}.
 */
export type HapticaPatternInsert = Pick<HapticaPattern, "name" | "ahapPattern">;

/**
 * Required fields for updating an existing {@link HapticaPattern}.
 */
export type HapticaPatternUpdate = {
  id: HapticaPatternID;
  name?: string;
  ahapPattern?: string;
};

/**
 * A class for reading and writing {@link HapticaPattern}s from your extension.
 */
export class HapticaPatterns {
  private constructor(key: Symbol) {
    _hapticaInternalConstructorCheck(key);
  }

  /**
   * Returns an array of patterns for the specified {@link HapticaPatternsQuery}.
   */
  async patterns(query: HapticaPatternsQuery) {
    return await _hapticaPrimitives.patterns(query);
  }

  /**
   * Returns an {@link HapticaPattern} for the specified {@link HapticaPatternID} if one exists.
   */
  async patternById(id: HapticaPatternID) {
    return await _hapticaPrimitives.patternById(id);
  }

  /**
   * Inserts a new {@link HapticaPattern}.
   *
   * @param insert The required fields to insert a new pattern.
   * @returns The {@link HapticaPatternID} of the inserted pattern.
   */
  async insertPattern(insert: HapticaPatternInsert) {
    return (await this.insertPatterns([insert]))[0];
  }

  /**
   * Inserts new {@link HapticaPattern}s.
   *
   * @param inserts The required fields to insert new patterns.
   * @returns The {@link HapticaPatternID}s of the inserted patterns.
   */
  async insertPatterns(inserts: HapticaPatternInsert[]) {
    return await _hapticaPrimitives.insertPatterns(inserts);
  }

  /**
   * Updates an existing {@link HapticaPattern}.
   *
   * @param update The required fields to update an existing pattern.
   * @returns The {@link HapticaPatternID} of the updated pattern.
   */
  async updatePattern(update: HapticaPatternUpdate) {
    return (await this.updatePatterns([update]))[0];
  }

  /**
   * Updates existing {@link HapticaPattern}s.
   *
   * @param updates The required fields to update existing patterns.
   * @returns The {@link HapticaPatternID}s of the updated patterns.
   */
  async updatePatterns(updates: HapticaPatternUpdate[]) {
    return await _hapticaPrimitives.updatePatterns(updates);
  }

  /**
   * Deletes an existing {@link HapticaPattern}.
   *
   * @param id The {@link HapticaPatternID} of the pattern to delete.
   */
  async deletePatternById(id: HapticaPatternID) {
    await this.deletePatternByIds([id]);
  }

  /**
   * Deletes existing {@link HapticaPattern}s.
   *
   * @param ids The {@link HapticaPatternID}s of the patterns to delete.
   */
  async deletePatternByIds(ids: HapticaPatternID[]) {
    await _hapticaPrimitives.deletePatterns(ids);
  }
}

/**
 * A type for describing a device's hardware support for haptics.
 */
export type HapticaDeviceHardwareCapability = {
  /**
   * Whether or not haptic feedback is supported by the hardware.
   */
  isFeedbackSupported: boolean;

  /**
   * Whether or not the haptics engine can play audio alongside feedback.
   */
  isAudioSupported: boolean;
};

/**
 * Metadata on the user's device.
 */
export type HapticaDeviceMetadata = {
  /**
   * The model name of the user's device.
   */
  modelName: string;

  /**
   * The os version of the user's device.
   */
  osVersion: HapticaSemanticVersion;

  /**
   * The hardware haptic compatability of the user's device.
   */
  hapticHardwareCompatability: HapticaDeviceHardwareCapability;
};

/**
 * A class for extension key value storage.
 *
 * Do not construct instances of this class, use the `keyValueStorage` property instead.
 */
export class HapticaKeyValueStore {
  private constructor(
    key: Symbol,
    private readonly source: _HapticaKVSSource,
  ) {
    _hapticaInternalConstructorCheck(key);
  }

  /**
   * Returns the value for the specified key or undefined if no value exists.
   */
  value(key: string) {
    return _hapticaPrimitives.keyValueStorageValue(key, this.source);
  }

  /**
   * Sets the value for the specified key.
   */
  setValue(key: string, value: string) {
    _hapticaPrimitives.keyValueStorageSetValue(key, value, this.source);
  }

  /**
   * Removes the value for the specified key.
   */
  removeValue(key: string) {
    _hapticaPrimitives.keyValueStorageRemoveValue(key, this.source);
  }
}

/**
 * An appropriate value to use for a settings schema.
 */
export type HapticaExtensionSettingsValue = string | number | boolean | Date;

/**
 * A change in a settings value.
 */
export type HapticaExtensionSettingsChange = {
  /**
   * The name of the changed settings value.
   */
  name: string;

  /**
   * The new value.
   */
  newValue: HapticaExtensionSettingsValue;

  /**
   * The previous value.
   */
  previousValue: HapticaExtensionSettingsValue;
};

export type HapticaExtensionSettingsValidationResult =
  | { status: "success" }
  | { status: "error"; message: string };

/**
 * A attribute for a setting value.
 *
 * Attributes affect how the app treats the setting value. For instance, the `"secure"` attribute
 * will ensure that the setting value is persisted in secure storage (ie. Keychain).
 */
export type HapticaSettingAttribute = "secure";

type BaseSettingsSchema<Value extends HapticaExtensionSettingsValue> = {
  /**
   * The unique name of the settings value.
   */
  key: string;

  /**
   * A display name for the settings value that gets displayed on the extension settings screen.
   */
  displayName?: string;

  /**
   * A title that gets displayed for the form section of this setting on the extension settings
   * screen.
   */
  displayTitle?: string;

  /**
   * A description for this setting that gets displayed on the extension settings screen.
   */
  description?: string;

  /**
   * The default value for this setting.
   */
  defaultValue: Value;

  /**
   * The setting's attributes.
   */
  attributes?: HapticaSettingAttribute[];

  /**
   * A function to validate the settings value when the user decides to change it.
   *
   * @param value The new prospective value.
   * @returns An {@link HapticaExtensionSettingsValidationResult}.
   */
  validate?: (value: Value) => HapticaExtensionSettingsValidationResult;
};

type BaseNumericalSettingsSchema = BaseSettingsSchema<number> & {
  format?: (value: number) => string;
  step: number;
};

/**
 * The type of keyboard to use for a text field.
 */
export type TextFieldKeyboardType =
  | "default"
  | "asciiCapable"
  | "numbersAndPunctuation"
  | "URL"
  | "numberPad"
  | "phonePad"
  | "namePhonePad"
  | "emailAddress"
  | "decimalPad"
  | "twitter"
  | "webSearch"
  | "asciiCapableNumberPad";

/**
 * A style for a date picker.
 */
export type DatePickerStyle =
  | "automatic"
  | "compact"
  | "field"
  | "graphical"
  | "stepperField"
  | "wheel";

/**
 * Which components to display for a date picker.
 */
export type DatePickerDisplayedComponents = "date" | "hourAndMinute";

/**
 * An option to display in a picker.
 */
export type PickerOption = { displayName: string; value: string };

/**
 * A schema for describing settings value.
 *
 * Users change the settings for your extension on the extensions settings screen. You can use this
 * type to determine the UI and type for a settings value.
 */
export type HapticaExtensionSettingsSchema =
  | ({ type: "toggle" } & BaseSettingsSchema<boolean>)
  | ({ type: "text-field" } & BaseSettingsSchema<string> & {
        placeholder?: string;
        lineLimit?: number;
        autoCorrectionDisabled?: boolean;
        keyboardType?: TextFieldKeyboardType;
      })
  | ({ type: "stepper" } & BaseNumericalSettingsSchema & {
        min?: number;
        max?: number;
      })
  | ({ type: "slider" } & BaseNumericalSettingsSchema & {
        min: number;
        max: number;
        includeStepper?: boolean;
      })
  | ({ type: "date-picker" } & BaseSettingsSchema<Date> & {
        min?: Date;
        max?: Date;
        style?: DatePickerStyle;
        displayedComponents?: DatePickerDisplayedComponents[];
      })
  | ({ type: "picker" } & BaseSettingsSchema<string> & {
        options: PickerOption[];
      });

export type HapticaValidateSettingResult<
  Value extends HapticaExtensionSettingsValue,
> = { status: "success"; value: Value } | { status: "error"; message: string };

/**
 * Validates the specified {@link HapticaExtensionSettingsValue} against the schema.
 *
 * @param schema The schema to validate against.
 * @param value The value to validate.
 * @returns An {@link HapticaValidateSettingResult}.
 */
export const hapticaValidateSetting = <
  S extends HapticaExtensionSettingsSchema,
>(
  schema: S,
  value: HapticaExtensionSettingsValue,
): HapticaValidateSettingResult<S["defaultValue"]> => {
  const typeErrorMessage = _hapticaSettingTypeErrorMessage(schema, value);
  if (typeErrorMessage) {
    return { status: "error", message: typeErrorMessage };
  }
  const validateResult = schema.validate?.(value as never); // NB: Runtime typecheck above.
  if (validateResult?.status === "error") {
    return validateResult;
  }
  const rangeErrorMessage = _hapticaSettingRangeCheckErrorMessage(
    schema,
    value,
  );
  if (rangeErrorMessage) {
    return { status: "error", message: rangeErrorMessage };
  }
  return { status: "success", value: value as S["defaultValue"] };
};

const _hapticaSettingRangeCheckErrorMessage = (
  schema: HapticaExtensionSettingsSchema,
  value: HapticaExtensionSettingsValue,
): string | undefined => {
  if (
    schema.type !== "stepper" &&
    schema.type !== "slider" &&
    schema.type !== "date-picker"
  ) {
    return undefined;
  }
  if (!(value instanceof Date) && !(typeof value === "number")) {
    return undefined;
  }
  if (schema.type === "date-picker" && value instanceof Date) {
    const min = schema.min ?? new Date(-8.64e15);
    const max = schema.max ?? new Date(8.64e15);
    if (value < min) {
      return `The received value (${value.toISOString()}) is below the minimum value of ${min.toISOString()}.`;
    } else if (value > max) {
      return `The received value (${value.toISOString()}) is above the maximum value of ${max.toISOString()}.`;
    } else {
      return undefined;
    }
  }
  const min = schema.min ?? -Infinity;
  const max = schema.max ?? Infinity;
  if (value < min) {
    return `The received value (${value}) is below the minimum value of ${min}.`;
  } else if (value > max) {
    return `The received value (${value}) is above the maximum value of ${max}.`;
  } else {
    return undefined;
  }
};

const _hapticaSettingTypeErrorMessage = (
  schema: HapticaExtensionSettingsSchema,
  value: HapticaExtensionSettingsValue,
): string | undefined => {
  const schemaType = _hapticaSettingSchemaTypeName(schema);
  const valueType = _hapticaSettingValueTypeName(value);
  if (schemaType !== valueType) {
    return `Expected type '${schemaType}', but received '${valueType}'.`;
  }
  return undefined;
};

const _hapticaSettingSchemaTypeName = (
  schema: HapticaExtensionSettingsSchema,
) => {
  const map = {
    toggle: "boolean",
    "text-field": "string",
    stepper: "number",
    slider: "number",
    picker: "string",
    "date-picker": "Date",
  };
  return map[schema.type];
};

const _hapticaSettingValueTypeName = (value: HapticaExtensionSettingsValue) => {
  if (
    typeof value === "object" &&
    "constructor" in value &&
    "name" in value.constructor
  ) {
    return value.constructor.name;
  }
  return typeof value;
};

/**
 * A class for reading and editing the settings for your extension.
 *
 * You don't construct instances of this class, instead you call `extension.settings()` to retrieve
 * the settings for your extension.
 */
export class HapticaExtensionSettings {
  private constructor(key: Symbol) {
    _hapticaInternalConstructorCheck(key);
  }

  /**
   * Returns the value for the settings name.
   *
   * @param settingName The settings name that was used in the `settingsSchemas` of your extension's manifest.
   * @returns The value for the settings name.
   */
  value(settingName: string): HapticaExtensionSettingsValue {
    return _hapticaPrimitives.settingsValue(settingName);
  }

  /**
   * Sets the value for the settings name.
   *
   * @param settingName The settings name that was used in the `settingsSchemas` of your extension's manifest.
   * @param value The value to set for the setting.
   */
  setValue(settingName: string, value: HapticaExtensionSettingsValue) {
    _hapticaPrimitives.setSettingsValue(settingName, value);
  }

  /**
   * Returns true if the setting name is in the `settingsSchemas` of your extension's manifest.
   *
   * @param settingName A setting name.
   */
  has(settingName: string): boolean {
    return _hapticaPrimitives.settingsHasValue(settingName);
  }
}

export type HapticaExtensionID = string;

/**
 * A type describing the capabilities of a Haptica Extension.
 *
 * You register instances of this object like so:
 * ```ts
 * extension.registerManifest({
 *   name: "My Extension",
 *   description: "This is a cool extension",
 *   onLoadPatterns: async () => {
 *     // Fetch haptic patterns to display in the app...
 *   }
 * })
 * ```
 */
export type HapticaExtensionManifest = {
  /**
   * The name of this extension.
   */
  name: string;

  /**
   * A description of this extension.
   */
  description?: string;

  /**
   * The author of this extension.
   */
  author?: string;

  /**
   * A description of the settings of this extension.
   */
  settingsSchemas?: HapticaExtensionSettingsSchema[];

  /**
   * A callback the runs whenever the user changes your extension's settings.
   *
   * The updated settings will have already been applied to the settings storage when this callback
   * is invoked.
   *
   * @param changes A list of {@link HapticaExtensionSettingsChange}s.
   */
  onSettingsChanged?: (
    changes: HapticaExtensionSettingsChange[],
  ) => Promise<void>;

  /**
   * A callback that runs whenever the extension has been loaded by the app.
   */
  onExtensionLoaded?: () => Promise<void>;

  /**
   * A callback that runs when your extension has been deleted by the user.
   *
   * You can use this callback to perform any cleanup work that your extension needs on deletion.
   *
   * This callback runs regardless of whether or not the extension has been enabled.
   */
  onExtensionDeleted?: () => Promise<void>;

  /**
   * A callback that runs when your extension has been disabled by the user.
   *
   * When your extension is disabled, the app will not invoke the callbacks that you define in
   * your extension manifest, except for `onExtensionDeleted`.
   */
  onExtensionDisabled?: () => Promise<void>;

  /**
   * A callback the runs when the user shares a haptic patterns with your extension.
   *
   * @param patterns An array of {@link HapticaPattern}s.
   */
  onPatternsShared?: (patterns: HapticaPattern[]) => Promise<void>;

  /**
   * A callback that runs whenever haptic patterns have been updated.
   *
   * The update will have already been applied to the persisted location of the pattern when this
   * callback is invoked.
   *
   * Your extension must have read access to the patterns in order for this callback to be invoked.
   *
   * @param patterns An array of {@link HapticaPattern}s.
   */
  onPatternsUpdated?: (patterns: HapticaPattern[]) => Promise<void>;

  /**
   * A callback that runs whenever haptic patterns have been deleted.
   *
   * The deletion will have already been applied to the persisted location of the patterns when this
   * callback is invoked.
   *
   * Your extension must have read access to the patterns in order for this callback to be invoked.
   *
   * @param patterns An array of {@link HapticaPattern}s.
   */
  onPatternsDeleted?: (patterns: HapticaPattern[]) => Promise<void>;
};

/**
 * A union of access permission identifiers for your extension.
 *
 * `"read-global-patterns"` = Your extension has read-only access to all patterns stored in the app.
 *
 * `"read-global-audio"` = Your extension has read-only access to all audio files stored in the app.
 *
 * `"read-write-local-patterns"` = Your extension has read-write access to a list of patterns that it privately owns.
 *
 * `"read-write-local-audio"` = Your extension has read-write access to a list of audio files that it privately owns.
 */
export type HapticaAccessPermissions =
  | "read-global-patterns"
  | "read-global-audio"
  | "read-write-local-patterns"
  | "read-write-local-audio";

/**
 * A request to ask for permissions to access app resources from your extension.
 */
export type HapticaAccessPermissionsRequest = {
  /**
   * The reason that your extension needs access to {@link HapticaPattern}s.
   */
  patternsAccessReason?: string;

  /**
   * The reason that your extension needs access to {@link HapticaAudioFile}s.
   */
  audioAccessReason?: string;
};

/**
 * A class representing Haptica in your extension.
 *
 * You do not construct instances of this class. Instead, use the global {@link haptica} instance.
 */
export class Haptica {
  /**
   * The {@link HapticaDeviceMetadata} of the device running your extension.
   */
  get deviceMetadata() {
    return _hapticaPrimitives.deviceMetadata;
  }

  /**
   * Key Value Storage for your extension.
   *
   * Do not store sensitive data such as passwords or API keys in key value storage. Instead use
   * {@link Haptica.secureStorage} for storing sensitive data.
   */
  readonly keyValueStorage = _hapticaConstructPrivate<HapticaKeyValueStore>(
    HapticaKeyValueStore,
    "normal",
  );

  /**
   * Secure Key Value Storage for your extension.
   *
   * You can use secure storage to store sensitive data such as passwords or API keys.
   * Non-sensitive data should be stored in {@link Haptica.keyValueStorage}.
   */
  readonly secureStorage = _hapticaConstructPrivate<HapticaKeyValueStore>(
    HapticaKeyValueStore,
    "secure",
  );

  /**
   * Access to {@link HapticaPattern}s in your extension.
   */
  readonly patterns =
    _hapticaConstructPrivate<HapticaPatterns>(HapticaPatterns);

  /**
   * Access to audio files for your extension.
   */
  readonly audioDirectory = _hapticaConstructPrivate<HapticaAudioDirectory>(
    HapticaAudioDirectory,
  );

  /**
   * The settings for your extension.
   */
  readonly extensionSettings =
    _hapticaConstructPrivate<HapticaExtensionSettings>(
      HapticaExtensionSettings,
    );

  /**
   * The unique identifier for your extension.
   */
  get extensionId(): HapticaExtensionID {
    return _hapticaPrimitives.extensionID;
  }

  /**
   * The {@link HapticaResourceOwner} value for your extension.
   */
  get extensionResourceOwner(): HapticaResourceOwner {
    return { type: "extension", id: this.extensionId };
  }

  /**
   * The registered {@link HapticaExtensionManifest}, if `registerExtensionManifest` has been called.
   */
  get extensionManifest() {
    return _hapticaPrimitives.extensionManifest;
  }

  /**
   * True if an {@link HapticaExtensionManifest} has been registered.
   */
  get isExtensionManifestRegistered() {
    return !!this.extensionManifest;
  }

  private constructor(key: Symbol) {
    _hapticaInternalConstructorCheck(key);
  }

  /**
   * Registers the manifest for this extension.
   *
   * @param manifest See {@link HapticaExtensionManifest}.
   */
  registerExtensionManifest(manifest: HapticaExtensionManifest) {
    _hapticaPrimitives.registerExtensionManifest(manifest);
  }

  /**
   * Requests permission to access resources from the app.
   *
   * @param request An {@link HapticaAccessPermissionsRequest}.
   * @returns A set of granted permissions.
   */
  async requestAccessPermissions(request: HapticaAccessPermissionsRequest) {
    return _hapticaPrimitives.requestAccessPermissions(request);
  }

  /**
   * Returns the set of granted permissions to your extension.
   */
  async accessPermissions() {
    return _hapticaPrimitives.accessPermissions();
  }
}

/**
 * An object containing core properties to this extension.
 */
const haptica = _hapticaConstructPrivate<Haptica>(Haptica);

const HAPTICA_AVFOUNDATION_MIME_TYPES = {
  mp3: "audio/mpeg",
  aac: "audio/aac",
  m4a: "audio/mp4",
  wav: "audio/wav",
  caf: "audio/x-caf",
  aif: "audio/aiff",
  aiff: "audio/aiff",
  alac: "audio/x-alac",
} as const;

/**
 * The supported audio mime types for the app.
 */
const HAPTICA_SUPPORTED_AUDIO_MIME_TYPES = [
  ...Object.values(HAPTICA_AVFOUNDATION_MIME_TYPES),
  "application/octet-stream",
] as const;

/**
 * A union of mime types that Haptica supports.
 */
export type HapticaAudioMIMEType =
  (typeof HAPTICA_SUPPORTED_AUDIO_MIME_TYPES)[number];

export {
  haptica,
  HAPTICA_SUPPORTED_AUDIO_MIME_TYPES,
  HAPTICA_AHAP_AUDIO_PARAMETER_IDS,
  HAPTICA_AHAP_HAPTIC_PARAMETER_IDS,
  HAPTICA_AHAP_DYNAMIC_PARAMETER_IDS,
  HAPTICA_AHAP_CURVABLE_PARAMETER_IDS,
};
